# Testing modules

This tutorial will walk you through testing a module. You can choose what kind of account you want to test the module on.

This tutorial uses Foundry, a toolchain to simplify and speed up smart contract development. If you are not familiar with Foundry, feel free to check out [their docs](https://book.getfoundry.sh/).

    If you do not have foundry installed, run the following command and follow the onscreen instructions: ```bash curl
    -L https://foundry.paradigm.xyz | bash ```

## Installation

1. Get started with ModuleKit by using our template or adding it into an existing foundry project:

   ```bash {{ title: "template" }}
   git clone https://github.com/rhinestonewtf/module-template.git
   cd module-template
   forge install
   ```

   ```bash {{ title: "existing foundry project" }}
   forge install rhinestonewtf/modulekit
   ```

## Testing the module

    In this section, we will walk you through testing a simple validator.

2. Duplicate the file `test/validators/ValidatorTemplate.t.sol` and rename to `SimpleValidator.t.sol` and the contract to `SimpleValidatorTest`.

   If you added the ModuleKit to an existing project, you will need to create the `SimpleValidator.t.sol` file yourself
   and copy the code from
   [here](https://github.com/rhinestonewtf/module-template/tree/main/test/validators/ValidatorTemplate.t.sol).

3. Add the following import statement to the top of the file:

```solidity
import { ECDSA } from "solady/utils/ECDSA.sol";
```

and change the following import

```solidity
import { ValidatorTemplate, ERC1271_MAGICVALUE } from "../../src/validators/ValidatorTemplate.sol";
```

to the following:

```solidity
import { SimpleValidator, ERC1271_MAGICVALUE } from "../../src/validators/SimpleValidator.sol";
```

and then change the code above the `setup` function to the following:

```solidity
contract SimpleValidatorTest is Test, RhinestoneModuleKit {
    using RhinestoneModuleKitLib for RhinestoneAccount;
    using ECDSA for bytes32;

    RhinestoneAccount instance;
    SimpleValidator simpleValidator;

    ...
}
```

4. Edit the contract functions to match the following code:

**setUp**

```solidity
function setUp() public {
    // Setup account
    instance = makeRhinestoneAccount("1");
    vm.deal(instance.account, 10 ether);

    // Setup validator
    simpleValidator = new SimpleValidator();
    (address owner,) = makeAddrAndKey("owner");
    vm.prank(instance.account);
    simpleValidator.setOwner(owner);

    // Add validator to account
    instance.addValidator(address(simpleValidator));
}
```

This function sets up the tests by creating an instance of the account, deploying and initialising the validator, and adding the validator to the account.

**testSendEth**

```solidity
function testSendEth() public {
    // Create userOperation fields
    address receiver = makeAddr("receiver");
    uint256 value = 10 gwei;
    bytes memory callData = "";

    // Create signature
    (, uint256 key) = makeAddrAndKey("owner");
    bytes32 hash =
        instance.getUserOpHash({ target: receiver, value: value, callData: callData });
    (uint8 v, bytes32 r, bytes32 s) = vm.sign(key, hash.toEthSignedMessageHash());
    bytes memory signature = abi.encode(abi.encodePacked(r, s, v), address(simpleValidator));

    // Create userOperation
    instance.exec4337({
        target: receiver,
        value: value,
        callData: callData,
        signature: signature
    });

    // Validate userOperation
    assertEq(receiver.balance, 10 gwei, "Receiver should have 10 gwei");
}
```

This function tests that the validator is setup and called correctly during the `validateUserOp` function by creating a UserOperation, signing it, and then executing it.

**test1271Signature**

```solidity
function test1271Signature() public {
    // Create signature
    (, uint256 key) = makeAddrAndKey("owner");
    bytes32 hash = keccak256("signature");
    (uint8 v, bytes32 r, bytes32 s) = vm.sign(key, hash.toEthSignedMessageHash());
    bytes memory signature = abi.encodePacked(r, s, v);

    // Validate signature
    vm.prank(instance.account);
    bytes4 returnValue = simpleValidator.isValidSignature(hash, signature);

    // Validate signature success
    assertEq(
        returnValue,
        ERC1271_MAGICVALUE, // EIP1271_MAGIC_VALUE
        "Signature should be valid"
    );
}
```

This function tests that the validator behaves correctly during the `isValidSignature` function by creating a signature and then checking that the signature is validated by the validator.

In this section, we will walk you through testing a simple executor.

2. Duplicate the file `test/executors/ExecutorTemplate.t.sol` and rename it to `SimpleExecutor.t.sol` and the contract to `SimpleExecutorTest`.

   If you added the ModuleKit to an existing project, you will need to create the `SimpleExecutor.sol` file yourself
   and copy the code from
   [here](https://github.com/rhinestonewtf/module-template/tree/main/test/executors/ExecutorTemplate.t.sol).

3. Add the following import statements to the top of the file:

```solidity
import { SimpleExecutor, IERC20, IExecutorManager } from "../../src/executors/SimpleExecutor.sol";
import { MockERC20 } from "solmate/test/utils/mocks/MockERC20.sol";
```

and remove the following import:

```solidity
import { ExecutorTemplate } from "../../src/executors/ExecutorTemplate.sol";
```

and then change the code above the `setup` function to the following:

```solidity
contract SimpleExecutorTest is Test, RhinestoneModuleKit {
    using RhinestoneModuleKitLib for RhinestoneAccount;

    RhinestoneAccount instance;
    SimpleExecutor simpleExecutor;
    MockERC20 token;

    ...
}
```

4. Remove the `testExecuteAction` function and edit the contract to hold the following two functions:

**setUp**

```solidity
function setUp() public {
    // Setup account
    instance = makeRhinestoneAccount("1");
    vm.deal(instance.account, 10 ether);

    // Setup executor
    simpleExecutor = new SimpleExecutor();

    // Add executor to account
    instance.addExecutor(address(simpleExecutor));

    // Setting up mock token
    token = new MockERC20("", "", 18);
    token.mint(instance.account, 10_000_000 ether);
}
```

This function sets up the tests by creating an instance of the account, deploying and initialising the executor, and adding the executor to the account.

**testExecuteSchedule**

```solidity
function testExecuteSchedule() public {
    // Setup recipient
    address recipient = makeAddr("recipient");

    // Add schedule
    vm.prank(instance.account);
    simpleExecutor.addSchedule(recipient, IERC20(address(token)), 100, 1);

    // Execute schedule
    vm.warp(block.timestamp + 1 days);
    simpleExecutor.executeSchedule(
        IExecutorManager(address(instance.aux.executorManager)), instance.account, 0
    );

    // Assert
    assertEq(token.balanceOf(recipient), 100);
}
```

This function tests that the executor is setup and called correctly during the `executeSchedule` function by creating a schedule, changing the block timestamp so that the schedule becomes due, and then executing the schedule.

4. Run `forge test` to run the tests and ensure that they pass. You should see something like the following message:

```bash {{title: "response"}}
Running 1 test for ...
[PASS] ...() (gas: ...)
Test result: ok. 1 passed; 0 failed; 0 skipped; finished in 18.85ms

Ran 2 test suites: 5 tests passed, 0 failed, 0 skipped (5 total tests)
```

### Congratulations, you just wrote your first module test!
