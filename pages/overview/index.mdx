import Image from 'next/image'
import { Cards } from 'nextra/components'
import { ComponentCard } from '../../components/ComponentCard'
import { ModuleKitIcon, SDKIcon, LogoIcon } from '../../components/icons'

# Why Rhinestone?

Rhinestone provides infrastructure and tooling for building products with modular smart accounts. Our technology stack is smart account-agnostic (compatible with Safe, Biconomy, ZeroDev, and any [ERC-7579](https://erc7579.com) compliant account) and ERC-4337 infrastructure-agnostic (compatible with all leading account abstraction SDKs and bundlers).

Rhinestone is specifically focused on smart account modules. Modules are self-contained smart contracts that extend the feature set of any smart account. Our infrastructure and tooling support the full lifecycle of a module, from development to deployment, through audits, and to usage at the application layer.

Reasons to build with Rhinestone:

- Level up your product with a library of modules that are ready to be used within your application
- Develop the module you need to power an advanced smart account-native product or service
- Develop a product that works with any [ERC-7579](https://erc7579.com) account (incl. Safe, Biconomy’s Nexus, ZeroDev’s Kernel, OKX smart wallet, and many more)

## Our stack

We aim to make building onchain applications with smart account modules as simple and accessible as possible. Our approach to achieving this spans three primary focus areas:

<Cards className="gap-x-[15px]">
<ComponentCard
  component={{
    icon: <SDKIcon width={48} height={48} />,
    title: "ModuleSDK",
    description:
      "A TypeScript library for using smart account modules in applications. The ModuleSDK supports Safe and any ERC-7579 account, and is built to be used with existing AA SDKs.",
href: "/module-sdk",
}}
/>

<ComponentCard
  component={{
    icon: <ModuleKitIcon width={48} height={48} />,
    title: 'ModuleKit',
    description:
      'The fastest way to start building a smart account module is by using ModuleKit, a development kit for building and testing account-agnostic modules',
    href: '/modulekit',
  }}
/>

<ComponentCard
  component={{
    icon: (<LogoIcon width={48} height={48}/>),
    title: "Automations",
    description:
      "Onchain and offchain services to support an open and permissionless module ecosystem that is smart account-agnostic, solving solve interoperability, security, distribution, and monetization.",
      href: "/automations",
  }}
/>
</Cards>

## The problem that got us started

Today, there are significant barriers to developing products that utilize the full potential of smart accounts: developer complexity, security, and a lack of simple feature customization, which leads to vendor lock-in and ecosystem fragmentation.

These challenges paint a picture of a homogenous smart account ecosystem where building novel features is costly, expensive audits disincentivize experimentation, and high switching costs increase user adoption risk.

We envision a world where smart accounts are simple (from a DevEx perspective), extensible, portable, and secure. Our unique modular smart account infrastructure and tooling achieve this. We transform the smart account into an open platform where any third-party developer can develop self-contained features (in the form of modules) that can be installed and used by any application developer or user.

## Build with existing tools

The best tools improve the developer's life and don’t require a steep learning curve. For this reason, we designed the ModuleSDK to leverage [viem](https://viem.sh), one of the most popular libraries for Ethereum developers, and to be compatible as a companion tool with all existing account abstraction SDKs (including [permissionless.js](https://docs.pimlico.io/permissionless), [Biconomy SDK](https://docs.biconomy.io/quickstart), [ZeroDev SDK](https://docs.zerodev.app/), and [userop.js](https://docs.stackup.sh/docs/useropjs)).

ModuleKit has been developed on top of Foundry and aims to abstract away as many complexities as possible when it comes to building and testing modules. It provides templates to get you started, module bases for common functions, and frameworks that allow you to test your module against multiple smart account implementations through one single variable change.

## Avoid vendor lock-in

Our tools, modules, and services are built to be smart account-agnostic and 4337 infrastructure-agnostic. We led the development of [ERC-7579](https://erc7579.com), the leading standard for modular smart accounts, to increase the interoperability of modules across smart accounts. This serves two purposes: one, it ensures developers need only build once to maximize their audience, and two, it ensures our developers are not locked into one single provider or ecosystem.
