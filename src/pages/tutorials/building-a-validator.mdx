# Building a validator

This tutorial will walk you through building a simple validator module. To learn more about validators, check out the [validators](/modules/validators) section of the docs.

This tutorial uses Foundry, a toolchain to simplify and speed up smart contract development. If you are not familiar with Foundry, feel free to check out [their docs](https://book.getfoundry.sh/).

<Note>
	If you do not have foundry installed, run the following command and follow the onscreen instructions: ```bash curl
	-L https://foundry.paradigm.xyz | bash ```
</Note>

## Installation

1. Get started with ModuleKit by using our template or adding it into an existing foundry project:

<CodeGroup title="Installation">

    ```bash {{ title: "template" }}
    git clone https://github.com/rhinestonewtf/module-template.git
    cd module-template
    forge install
    ````

    ```bash {{ title: "existing foundry project" }}
    forge install rhinestonewtf/modulekit
    ```

</CodeGroup>

## Building the validator

In this section, we will walk you through building a simple validator module.

2. Rename the file `src/validators/ValidatorTemplate.sol` to `SimpleValidator.sol` and the contract to `SimpleValidator`.

<Note>
	If you added the ModuleKit to an existing project, you will need to create the `SimpleValidator.sol` file yourself
	and copy the code from
	[here](https://github.com/rhinestonewtf/module-template/tree/main/src/validators/ValidatorTemplate.sol).
</Note>

3. Add the following import statement to the top of the file:

```solidity
import {ECDSA} from "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
```

and add the following code to the top of the contract:

```solidity
contract SimpleValidator is BaseValidator {
    using ECDSA for bytes32;

    mapping(address => address) public owners;

    function setOwner(address account, address owner) external {
        owners[account] = owner;
    }

    ...
}
```

4. Edit the contract functions to match the following code:

### validateUserOp

```solidity
function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash)
    external
    view
    override
    returns (uint256)
{
    bytes32 hash = userOpHash.toEthSignedMessageHash();
    if (owners[msg.sender] != hash.recover(userOp.signature)) {
        return SIG_VALIDATION_FAILED;
    }
    return VALIDATION_SUCCESS;
}
```

This function validates the userOperation by checking that the signature is valid and made by the owner of the account.

### recoverValidator

```solidity
 function recoverValidator(address recoveryModule, bytes calldata recoveryProof, bytes calldata recoveryData)
    external
    override
{
    owners[msg.sender] = abi.decode(recoveryData, (address));
}
```

This function recovers the validator by setting the owner of the account to the address in the `recoveryData` field.

Note that in this simple example, we do not check that the recovery proof is valid. This is a simplified example and you should not use this in production, otherwise your validator will be compromised.

### isValidSignature

```solidity
function isValidSignature(bytes32 signedDataHash, bytes memory moduleSignature)
    public
    view
    override
    returns (bytes4)
{
    bytes32 hash = signedDataHash.toEthSignedMessageHash();
    if (owners[msg.sender] != hash.recover(moduleSignature)) {
        return 0xffffffff;
    }
    return EIP1271_MAGIC_VALUE;
}
```

This function checks that the signature is valid and made by the owner of the account. This allows the validator to be used as an [EIP-1271](https://eips.ethereum.org/EIPS/eip-1271) validator.

## Testing the validator

In this section, we will walk you through testing the validator module that you just built.

5. Create a new file in `test/validators/SimpleValidator.t.sol`.

6. Add the following code:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import {Test} from "forge-std/Test.sol";
import {ECDSA} from "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import {RhinestoneModuleKit, RhinestoneModuleKitLib, RhinestoneAccount} from "@rhinestone/modulekit/test/utils/safe-base/RhinestoneModuleKit.sol";
import {SimpleValidator} from "../../src/validators/SimpleValidator.sol";

contract SimpleValidatorTest is Test, RhinestoneModuleKit {
    using RhinestoneModuleKitLib for RhinestoneAccount;
    using ECDSA for bytes32;

    RhinestoneAccount instance;
    SimpleValidator simpleValidator;

    function setUp() public {
        // Setup account
        instance = makeRhinestoneAccount("1");
        vm.deal(instance.account, 10 ether);

        // Setup validator
        simpleValidator = new SimpleValidator();
        (address owner, ) = makeAddrAndKey("owner");
        simpleValidator.setOwner(address(instance.account), owner);

        // Add validator to account
        instance.addValidator(address(simpleValidator));
    }

    function testSendEth() public {
        // Create userOperation fields
        address receiver = makeAddr("receiver");
        uint256 value = 10 gwei;
        bytes memory callData = "";
        uint8 operation = 0;

        // Create signature
        (, uint256 key) = makeAddrAndKey("owner");
        bytes32 hash = instance.getUserOpHash({
            target: receiver,
            value: value,
            callData: callData,
            operation: operation
        });
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(
            key,
            hash.toEthSignedMessageHash()
        );
        bytes memory signature = abi.encodePacked(r, s, v);

        // Create userOperation
        instance.exec4337({
            target: receiver,
            value: value,
            callData: callData,
            operation: operation,
            signature: signature
        });

        // Validate userOperation
        assertEq(receiver.balance, 10 gwei, "Receiver should have 10 gwei");
    }

    function testRecoverValidator() public {
        address newOwner = makeAddr("newOwner");
        // Recover validator
        vm.prank(instance.account);
        simpleValidator.recoverValidator(
            address(0),
            bytes(""),
            abi.encode(newOwner)
        );

        // Validate recovery success
        assertEq(
            simpleValidator.owners(address(instance.account)),
            newOwner,
            "Validator should be recovered"
        );
    }

    function test1271Signature() public {
        // Create signature
        (address owner, uint256 key) = makeAddrAndKey("owner");
        bytes32 hash = keccak256("Test signature");
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(
            key,
            hash.toEthSignedMessageHash()
        );
        bytes memory signature = abi.encodePacked(r, s, v);

        // Validate signature
        vm.prank(instance.account);
        bytes4 returnValue = simpleValidator.isValidSignature(hash, signature);

        // Validate signature success
        assertEq(
            returnValue,
            bytes4(0x1626ba7e), // EIP1271_MAGIC_VALUE
            "Signature should be valid"
        );
    }
}
```

The code above tests the validator module that you just built. It does this using four different functions:

-   `setUp` sets up the testing library by creating an instance of the account, deploying and initialising the validator, and adding the validator to the account.
-   `testSendEth` tests that the validator is setup and called correctly during the `validateUserOp` function by creating a UserOperation, signing it, and then executing it.
-   `testRecoverValidator` tests that the validator behaves correctly during the `recoverValidator` function by recovering the validator and then checking that the validator has been recovered.
-   `test1271Signature` tests that the validator behaves correctly during the `isValidSignature` function by creating a signature and then checking that the signature is validated by the validator.

7. Run `forge test` to run the tests and ensure that they pass. You should see the following message:

```bash {{title: "response"}}
Running 3 tests for test/validators/SimpleValidator.t.sol:SimpleValidatorTest
[PASS] test1271Signature() (gas: 19852)
[PASS] testRecoverValidator() (gas: 19877)
[PASS] testSendEth() (gas: 189121)
Test result: ok. 3 passed; 0 failed; 0 skipped; finished in 18.85ms
```
