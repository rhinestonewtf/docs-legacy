# Quick Start

The quickest way to get started with building a smart account module. This quickstart guide will walk you through building a simple validator module. To learn more about validators, check out the [validators](/modules/validators) section of the docs.

The high-level explanation is that validators are smart account modules that are called during the validation phase of a UserOperation. This means that their primary function is to verify the signature of a UserOperation and determine whether it is valid and should be executed.

This tutorial uses Foundry, a toolchain to simplify and speed up smart contract development. If you are not familiar with Foundry, feel free to check out [their docs](https://book.getfoundry.sh/).

<Note>
	If you do not have foundry installed, run the following command and follow the onscreen instructions: ```bash curl
	-L https://foundry.paradigm.xyz | bash ```
</Note>

## Installation

1. Get started with ModuleKit by using our template:

```bash
git clone https://github.com/rhinestonewtf/module-template.git
cd module-template
forge install
```

## Building the validator

In this section, we will walk you through building a simple validator module.

2. Rename the file `src/validators/ValidatorTemplate.sol` to `SimpleValidator.sol` and the contract to `SimpleValidator`.

3. Add the following import statement to the top of the file:

```solidity
import {ECDSA} from "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
```

and add the following code to the top of the contract:

```solidity
contract SimpleValidator is BaseValidator {
    using ECDSA for bytes32;

    mapping(address => address) public owners;

    function setOwner(address account, address owner) external {
        owners[account] = owner;
    }

    ...
}
```

4. Edit the contract functions to match the following code:

### validateUserOp

```solidity
function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash)
    external
    view
    override
    returns (uint256)
{
    bytes32 hash = userOpHash.toEthSignedMessageHash();
    if (owners[msg.sender] != hash.recover(userOp.signature)) {
        return SIG_VALIDATION_FAILED;
    }
    return VALIDATION_SUCCESS;
}
```

This function validates the userOperation by checking that the signature is valid and made by the owner of the account.

### recoverValidator

```solidity
 function recoverValidator(address recoveryModule, bytes calldata recoveryProof, bytes calldata recoveryData)
    external
    override
{
    owners[msg.sender] = abi.decode(recoveryData, (address));
}
```

This function recovers the validator by setting the owner of the account to the address in the `recoveryData` field.

Note that in this simple example, we do not check that the recovery proof is valid. This is a simplified example and you should not use this in production, otherwise your validator will be compromised.

### isValidSignature

```solidity
function isValidSignature(bytes32 signedDataHash, bytes memory moduleSignature)
    public
    view
    override
    returns (bytes4)
{
    bytes32 hash = signedDataHash.toEthSignedMessageHash();
    if (owners[msg.sender] != hash.recover(moduleSignature)) {
        return 0xffffffff;
    }
    return EIP1271_MAGIC_VALUE;
}
```

This function checks that the signature is valid and made by the owner of the account. This allows the validator to be used as an [EIP-1271](https://eips.ethereum.org/EIPS/eip-1271) validator.

**Congratulations, you just built your first validator!**

To continue on your journey, follow the steps below or head into our [tutorials](/tutorials) section for more walkthroughs, such as how to build different kinds of modules.

## Testing the validator

The rhinestone ModuleKit provides a testing framework to make it easy to test your modules. To learn how to test the `SimpleValidator`, continue with [this tutorial](/tutorials/building-a-validator#testing-the-validator). To learn more about the ModuleKit, check out the [ModuleKit](/modules/modulekit) section of the docs.

## Deploying the validator

Coming soon
